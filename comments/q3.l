/* 
 * ============================================================================
 * VERB RECOGNIZER LEXICAL ANALYZER
 * Built with Flex (Fast Lexical Analyzer Generator)
 * Purpose: Count specific English verbs in a text file
 * ============================================================================
 */

%{
/*
 * C DECLARATIONS SECTION
 * ======================
 * Code between %{ and %} is copied directly into the generated C program.
 * This section typically includes header files, global variables, and
 * function prototypes.
 */

#include <stdio.h>   /* Standard Input/Output library for printf() */

/* GLOBAL COUNTER VARIABLE
 * -----------------------
 * This variable will track how many verbs we find during scanning.
 * It's declared globally so it can be accessed from both the lexer
 * rules and the main function.
 */
int verb_count = 0;

%}
/*
 * End of C declarations section
 * =============================
 */

/*
 * RULES DEFINITION SECTION
 * ========================
 * This section defines patterns using regular expressions.
 * No patterns are defined here - we'll use literal patterns in rules.
 */

%%
/*
 * LEXICAL RULES SECTION
 * =====================
 * Each rule has the format: PATTERN { ACTION }
 * Flex scans input, finds matches, and executes corresponding C code.
 * Rules are checked in order (first match wins).
 */

/*
 * RULE 1: BE-VERBS PATTERN
 * -------------------------
 * Pattern: (is|am|are|were|was|be|being|been)
 * Matches any of these 8 forms of the verb "to be"
 * Uses parentheses for grouping and | for alternation (OR)
 * Example matches: "is" in "she is here", "are" in "we are ready"
 */
(is|am|are|were|was|be|being|been)    {
    /* ACTION: When a BE-verb is found */
    printf("BE verb found: '%s'\n", yytext);  /* Display the matched text */
    verb_count++;                            /* Increment the counter */
}

/*
 * RULE 2: MODAL/AUXILIARY VERBS PATTERN
 * -------------------------------------
 * Pattern: (do|does|did|will|would|should|can|could)
 * Matches common modal and auxiliary verbs
 * These are helping verbs that express ability, possibility, permission, etc.
 */
(do|does|did|will|would|should|can|could) {
    /* ACTION: When a modal/auxiliary verb is found */
    printf("Modal/Auxiliary verb found: '%s'\n", yytext);
    verb_count++;  /* Increment the counter */
}

/*
 * RULE 3: HAVE-VERBS PATTERN
 * --------------------------
 * Pattern: (has|have|had)
 * Matches three forms of the verb "to have"
 * These can be main verbs or auxiliary verbs (perfect tenses)
 */
(has|have|had)    {
    /* ACTION: When a HAVE-verb is found */
    printf("HAVE verb found: '%s'\n", yytext);
    verb_count++;  /* Increment the counter */
}

/*
 * RULE 4: GO-VERB PATTERN
 * -----------------------
 * Pattern: go
 * Matches only the base form "go" (not "goes", "going", "went", "gone")
 * This is a limitation - could be expanded with more forms
 */
go                {
    /* ACTION: When "go" is found */
    printf("GO verb found: '%s'\n", yytext);
    verb_count++;  /* Increment the counter */
}

/*
 * RULE 5: WHITESPACE AND PUNCTUATION IGNORER
 * ------------------------------------------
 * Pattern: [ \t\n.,!?;:'’"—]+
 * Character class matching one or more of:
 *   - Space, tab, newline
 *   - Standard punctuation: . , ! ? ; : '
 *   - Smart quotes/apostrophes: ’ (curly apostrophe)
 *   - Quotation marks: "
 *   - Em dash: —
 * ACTION: Empty {} means do nothing - we skip these characters entirely
 */
[ \t\n.,!?;:'’"—]+         /* Ignore whitespace and punctuation */

/*
 * RULE 6: CATCH-ALL IGNORER
 * -------------------------
 * Pattern: . (dot)
 * Matches ANY single character not matched by previous rules
 * This ensures we process every character in the input
 * ACTION: Empty {} means ignore all other characters
 */
.                     /* Ignore other characters */

%%
/*
 * END OF LEXICAL RULES
 * ====================
 */

/*
 * ADDITIONAL C CODE SECTION
 * =========================
 * This code is copied directly into the generated C program
 * after the lexer engine code.
 */

/*
 * MAIN FUNCTION - Program Entry Point
 * -----------------------------------
 * This function is called when the program starts
 */
int main() {
    /* PROGRAM HEADER - Display information to user */
    printf("=== Verb Recognizer ===\n");
    printf("Looking for verbs: is, am, are, were, was, be, being, been,\n");
    printf("do, does, did, will, would, should, can, could,\n");
    printf("has, have, had, go\n\n");
    /* The blank line (\n\n) improves readability */

    /*
     * START LEXICAL ANALYSIS
     * ----------------------
     * yylex() is the main lexer function generated by Flex
     * It will:
     * 1. Read input from stdin (or file redirected with <)
     * 2. Break input into tokens based on our rules
     * 3. Execute the corresponding action for each match
     * 4. Continue until end of input
     */
    yylex();

    /* PROGRAM RESULTS - Display final statistics */
    printf("\n=== Summary ===\n");
    printf("Total verbs found: %d\n", verb_count);
    
    /* Return 0 to indicate successful program execution */
    return 0;
}

/*
 * YYWRAP FUNCTION - End-of-Input Handler
 * --------------------------------------
 * Called automatically by Flex when it reaches end of input
 * Return value determines what happens next:
 *   - Return 1: Stop processing (we're done)
 *   - Return 0: Continue with another input file
 * We return 1 because this program processes only one input source
 */
int yywrap() {
    return 1;  /* Signal EOF (End of File) - no more input */
}

/*
 * ============================================================================
 * HOW THE PROGRAM WORKS STEP-BY-STEP:
 * ============================================================================
 * 
 * 1. COMPILATION PROCESS:
 *    flex verb.l              → Generates lex.yy.c (C source code)
 *    gcc lex.yy.c -o verb -lfl → Compiles to executable named 'verb'
 * 
 * 2. INPUT PROCESSING:
 *    When you run: ./verb < verb.txt
 *    - Input is read character by character
 *    - Flex tries to match against patterns in order
 *    - First matching rule wins
 * 
 * 3. MATCHING EXAMPLE:
 *    Input: "I am going"
 *    Step 1: 'I' → Rule 6 (.) → ignored
 *    Step 2: ' ' → Rule 5 (space) → ignored
 *    Step 3: 'a' → Rule 1 (starting "am") → continue
 *    Step 4: 'm' → Complete match "am" → Rule 1 action executes
 *            - Prints: "BE verb found: 'am'"
 *            - verb_count becomes 1
 *    Step 5: ' ' → Rule 5 → ignored
 *    Step 6: 'g' → Rule 6 → ignored
 *    Step 7: 'o' → Rule 6 → ignored
 *    Step 8: 'i' → Rule 6 → ignored
 *    Step 9: 'n' → Rule 6 → ignored
 *    Step 10: 'g' → Rule 6 → ignored
 * 
 * 4. OUTPUT:
 *    After all input processed, main() prints the total count
 * 
 * ============================================================================
 * LIMITATIONS AND ENHANCEMENTS:
 * ============================================================================
 * 
 * CURRENT LIMITATIONS:
 * - Only matches exact forms (not "goes", "going", "went")
 * - Case-sensitive (won't match "IS" or "Am")
 * - Doesn't handle contractions ("I'm", "we're")
 * - Word boundary issues with punctuation
 * 
 * POTENTIAL ENHANCEMENTS:
 * 1. Add case-insensitive matching: [Ii][Ss]|...
 * 2. Add more verb forms: goes, going, went, gone
 * 3. Handle contractions: I'm → am, we're → are
 * 4. Add context awareness (distinguish noun "can" vs verb "can")
 * 5. Categorize verbs (linking, helping, action)
 * 
 * ============================================================================
 */